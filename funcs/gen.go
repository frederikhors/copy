// +build ignore

package main

import (
	"log"
	"os"
	"strings"
	"text/template"
	"time"
)

const fileTemplate = `// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at
// {{ .Timestamp }}
package funcs

import (
	"time"
	"unsafe"
)

func init() {
    funcs = &CopyFuncs{
        funcs: map[funcKey]func(dst, src unsafe.Pointer){
            {{- range $types :=.Types}}{{range $dst := $types}}{{range $src := $types}} 
            // {{$src}} to {{$dst}}
            {Src: typeOf({{$src}}({{default $src}})), Dest: typeOf({{$dst}}({{default $dst}}))}:    copy{{title $src}}To{{title $dst}},
            {Src: typeOfPointer({{$src}}({{default $src}})), Dest: typeOf({{$dst}}({{default $dst}}))}:    copyP{{title $src}}To{{title $dst}},
            {Src: typeOf({{$src}}({{default $src}})), Dest: typeOfPointer({{$dst}}({{default $dst}}))}:    copy{{title $src}}ToP{{title $dst}},
            {Src: typeOfPointer({{$src}}({{default $src}})), Dest: typeOfPointer({{$dst}}({{default $dst}}))}:    copyP{{title $src}}ToP{{title $dst}},
            {{- end}}{{end}}{{end}}	
        },
        sizes: []func(dst, src unsafe.Pointer){
            {{range $size := $.Sizes -}}
            copy{{$size}},
            {{- end}} 
        },
    }
}
{{range $types :=.Types}}{{range $dst := $types}}{{range $src := $types}} 

// {{$src}} to {{$dst}}

func copy{{title $src}}To{{title $dst}}(dst, src unsafe.Pointer) {
	*(*{{$dst}})(unsafe.Pointer(dst)) = {{$dst}}(*(*{{$src}})(unsafe.Pointer(src)))
}

func copyP{{title $src}}To{{title $dst}}(dst, src unsafe.Pointer) {
	var v {{$dst}}
	if p := *(**{{$src}})(unsafe.Pointer(src)); p != nil {
		v = {{$dst}}(*p)
	}
	*(*{{$dst}})(unsafe.Pointer(dst)) = v
}

func copy{{title $src}}ToP{{title $dst}}(dst, src unsafe.Pointer) {
	v := {{$dst}}(*(*{{$src}})(unsafe.Pointer(src)))
	p := (**{{$dst}})(unsafe.Pointer(dst))
	if p := *p; p != nil {
		*p = v
		return
	}
	*p = &v
}

func copyP{{title $src}}ToP{{title $dst}}(dst, src unsafe.Pointer) {
	var v {{$dst}}
	if p := *(**{{$src}})(unsafe.Pointer(src)); p != nil {
		v = {{$dst}}(*p)
	}

	p := (**{{$dst}})(unsafe.Pointer(dst))
	if p := *p; p != nil {
		*p = v
		return
	}
	*p = &v
}
	
{{- end}}{{end}}{{end}}	

// Memcopy funcs
{{- range $size := $.Sizes}}
func copy{{$size}}(dst, src unsafe.Pointer) {
	*(*[{{$size}}]byte)(unsafe.Pointer(dst)) = *(*[{{$size}}]byte)(unsafe.Pointer(src))
}
{{end}} 
`

const maxBlockSize = 256

func title(s string) string {
	if strings.HasPrefix(s, "[]") {
		s = strings.TrimPrefix(s, "[]") + "s"
	}

	if parts := strings.Split(s, "."); len(parts) > 1 {
		s = parts[len(parts)-1]
	}

	return strings.Title(s)
}

func defaultValue(t string) string {
	switch t {
	case "bool":
		return "false"
	case "time.Time":
		return "time.Time{}"
	case "string":
		return `""`
	case "[]byte":
		return "nil"
	default:
		return "0"
	}
}

func createFile(path string) *os.File {
	file, err := os.Create(path)
	if err != nil {
		log.Fatalf(`unable to open file "%s": %s`, path, err)
	}

	return file
}

func main() {
	var data = struct {
		Timestamp time.Time
		Types     [][]string
		Sizes     []int
	}{
		Timestamp: time.Now().UTC(),
		Types: [][]string{
			{
				"int", "int8", "int16", "int32", "int64",
				"uint", "uint8", "uint16", "uint32", "uint64",
			},
			{"float32", "float64"},
			{"bool"},
			{"complex64", "complex128"},
			{"string", "[]byte"},
			{"time.Time"},
			{"time.Duration"},
		},
	}

	for i := 1; i <= maxBlockSize; i++ {
		data.Sizes = append(data.Sizes, i)
	}

	funcMap := template.FuncMap{
		"title":   title,
		"default": defaultValue,
	}

	tmpl, err := template.New("template").Funcs(funcMap).Parse(fileTemplate)
	if err != nil {
		log.Fatalf("parsing: %s", err)
	}

	file := createFile("funcs.gen.go")
	defer file.Close()

	err = tmpl.Execute(file, data)
	if err != nil {
		log.Fatalf("execution: %s", err)
	}
}
